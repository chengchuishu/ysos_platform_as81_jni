/**
 *@file customerdetstrategycallback.cpp
 *@brief the customer detect strategy call back
 *@version 1.0
 *@author LiShengJun
 *@date Created on: 2017-08-21 10:00:00
 *@copyright Copyright (c) 2016 YunShen Technology. All rights reserved.
 * 
 */
/// Private Headers //  NOLINT
#include "../include/customerdetstrategycallback.h"
#include "../../../public/include/common/commonenumdefine.h"

#include "../../../../../../core/trunk/main/public/include/core_help_package/utility.h"
#include "../../../../../../core/trunk/main/public/include/os_hal_package/bufferutility.h"

const double INFINATE_DIS = 99.0;
const char *INFINATE_CSTM_ID = "&##&";

const char *TTS_MODULE          = "default@TtsExtModule";
const char *TTS_IOCTL_ID        = "8139";

const char *AUDIO_CAPTURE       = "default@AudioCaptureExtModule";
const char *AUDIO_OPEN          = "26501";
const char *AUDIO_CLOSE         = "26502";

const char *CHASSIS_MODULE      = "default@ChassisModule1";

const char *ARTIFICIAL_MODULE   = "default@ArtificialAuxiliaryModule";

const char *FACE_DETECT_MODULE  = "default@FaceDetectModule1";

const char *WORK_STATE          = "work_state";
const char *IS_CHARGING         = "is_charging";
const char *IS_BATTERY_LOW      = "is_battery_low";

const char *ROBOT_STATE          = "robot_state";
const char *ROBOT_STATE_NULL     = "null";
const char *ROBOT_PREPARE_CRUISE = "prepare_cruise";
const char *ROBOT_CRUISE_SERVE   = "cruise_serve";
const char *ROBOT_RUN_MOVING     = "run_moving";
const char *ROBOT_MOVEPOINT_END  = "point_end";
const char *ROBOT_MOVEDIR_END    = "dir_end";
const char *ROBOT_GO_HOME        = "go_home";
const char *ROBOT_CHARGING       = "charging";
const char *ROBOT_FAIL_CHARGE    = "failcharge";

const char *CUSTOMER_STATUS     = "customer_status";
const char *FRONT_CONTROL       = "front_control";

const char *OBS_DIS_FRONT       = "chassis_obs_dis_front";
const char *OBS_NEAR_ANGLE      =  "chassis_obs_near";
const char *CHASSIS_COORDINATE  = "coordinate";

const char *LAST_CRUISE_STATUS  = "last_cruise_status";
const char *CURISE_ANS          = "curise_ans";

// customer server status
const char *SERVER_STATUS_IDLE = "0";          ///< 未服务状态        // NOLINT
const char *SERVER_STATUS_AT_SERVICE = "1";    ///< 服务状态          // NOLINT

enum FACE_DET_FLAG
{
    FACE_DET_INVAILD = -1,                  ///< 非法值

    FACE_DET_NONE = 0,                      ///< 不需要识别
    FACE_DET_UPDATE_ONLY,                   ///< 换人重新识别（不需要问候，不要切主页）

    FACE_DET_HOME_GREET,                    ///< 需要问候，需要切主页，默认换人
    FACE_DET_CHG_GREET,                     ///< 换人才问候，不要切主页，默认没换人
    FACE_DET_HOME_CHG_GREET,                ///< 换人才问候，需要切主页，默认没换人

    FACE_DET_HOME_GREET_SAME,               ///< 同一个人，切主页
};

namespace ysos {
    DECLARE_PLUGIN_REGISTER_INTERFACE (
                CustomerDetStrategyCallback,
                CallbackInterface );  ///<  插件的入口，一定要加上 //  NOLINT
    CustomerDetStrategyCallback::CustomerDetStrategyCallback (
                const std::string &strClassName ) :
        BaseStrategyCallbackImpl ( strClassName )
        , low_power_refuse_()
        , charging_serve_ ( true )
        , static_immediate_ ( false )
        , audio_open_ ( false )
        , prepare_cruise_tm_ ( 5.0 )
        , prepare_start_()
        , greet_dis_ ( 0.85 )
        , rcg_max_wait_ ( 1.5 )
        , rcg_start_()
        , HandleMessage_start_()
        , facedet_flag_ ( FACE_DET_NONE )
        , facedet_collect_ ( 0 )
        , may_change_ ( false )
        , chg_face_tm_()
        , face_chg_ctu_ ( 5.0 )
        , face_chg_rate_ ( 0.088 )
        , customer_num_ ( 0 )
        , customer_info_()
        , last_serve_tm_()
        , range_num ( 3 )
        , near_remind_falg_ ( false )
        , near_remind_tm_ ( 70 )
        , near_remind_()
        , mid_remind_falg_ ( false )
        , mid_remind_()
        , enfc_wait_tag_ ( 0 )
        , enfc_wait_start_()
        , enforce_wait_ ( 1.3 )
        , farewell_()
        , genderM ( "先生" )
        , genderF ( "女士" )
        , genderFM ( "大家" )
        , send_name_flag ( "0" )
        , send_name()
        , data_ptr_ ( GetDataInterfaceManager()->GetData (
                                GLOBAL_DATA_KEY ) )
    {
        logger_ = GetUtility()->GetLogger ( "ysos.obsdetstrategy" );
        dis_range_[0] = 0.9;
        dis_range_[1] = 1.1;
        dis_range_[2] = 1.3;
        wait_time_[0] = 90;
        wait_time_[1] = 30;
        wait_time_[2] = 15;
        ResetStatus();
    }

    CustomerDetStrategyCallback::~CustomerDetStrategyCallback (
                void )
    {
    }

    int CustomerDetStrategyCallback::Initialized (
                const std::string &key,
                const std::string &value )
    {
        YSOS_LOG_DEBUG ( key << ": " << value );
        int n_return = YSOS_ERROR_SUCCESS;
        if ( key == "charging_serve" )
        {
            charging_serve_ = ( value == "1" );
        }
        else if ( key == "static_immediate" )
        {
            static_immediate_ = ( value == "1" );
        }
        else if ( key == "low_power_refuse" )
        {
            low_power_refuse_ = value;
        }
        else if ( key == "prepare_cruise_tm" )
        {
            prepare_cruise_tm_ = atof ( value.c_str() );
        }
        else if ( key == "greet_distance" )
        {
            greet_dis_ = atof ( value.c_str() );
        }
        else if ( key == "recognise_max_wait" )
        {
            rcg_max_wait_ = atof ( value.c_str() );
        }
        else if ( key == "face_chg_rate" )
        {
            face_chg_rate_ = atof ( value.c_str() );
        }
        else if ( key == "face_chg_continue" )
        {
            face_chg_ctu_ = atof ( value.c_str() );
        }
        else if ( key == "distance_wait" )
        {
            unsigned int i = 0;
            range_num = 0;
            while ( range_num < DISTANCE_RANGE_MAXNUM
                        && 2 == sscanf ( value.c_str() + i, "%lf,%lf",
                                    &dis_range_[range_num],
                                    &wait_time_[range_num] ) )
            {
                range_num++;
                i = value.find ( '|', i );
                if ( i == std::string::npos )
                {
                    break;
                }
                i++;
            }
        }
        else if ( key == "near_remind" )
        {
            sscanf ( value.c_str(), "%d", &near_remind_tm_ );
            int i = value.find ( '|' );
            if ( i >= 0 )
            {
                near_remind_ = value.substr ( i + 1 );
            }
        }
        else if ( key == "mid_remind" )
        {
            mid_remind_ = value;
        }
        else if ( key == "enforce_wait" )
        {
            enforce_wait_ = atof ( value.c_str() );
        }
        else if ( key == "farewell" )
        {
            farewell_ = value;
        }
        else if ( key == "genderM" )
        {
            genderM = value;
        }
        else if ( key == "genderF" )
        {
            genderF = value;
        }
        else if ( key == "genderFM" )
        {
            genderFM = value;
        }
        else if ( key == "send_name_flag" )
        {
            send_name_flag = value;
        }
        return n_return;
    }

    int CustomerDetStrategyCallback::HandleMessage (const std::string &event_name, BufferInterfacePtr input_buffer, CallbackInterface *context )
    {
        YSOS_LOG_DEBUG ( "HandleMessage " << event_name );
        if ( data_ptr_ == NULL )
        {
            YSOS_LOG_ERROR ( "data_ptr_ is NULL" );
            return YSOS_ERROR_FAILED;
        }
        // robot state
        std::string robot_state;
        data_ptr_->GetData ( ROBOT_STATE, robot_state );
        YSOS_LOG_DEBUG ( "robot state: " << robot_state );
        // get customer status
        std::string customer_status;
        data_ptr_->GetData ( CUSTOMER_STATUS, customer_status );
        YSOS_LOG_DEBUG ( "customer status: " << customer_status );
        if ( event_name == "face_info" )
        {
            if ( CheckAvailable ( robot_state ) != YSOS_ERROR_SUCCESS )
            {
                return YSOS_ERROR_SUCCESS;
            }
            int face_num = 0;
            CstmFaceInfo face_info;
            int rst = ParserFaceInfo ( input_buffer, face_num, face_info );
            YSOS_LOG_DEBUG ( "ParserFaceInfo rst " << rst << " num " << face_num );
            if ( rst == -1 )
            {
                return YSOS_ERROR_FAILED;
            }
            // get chassis distance
            std::string str_distance;
            data_ptr_->GetData ( OBS_DIS_FRONT, str_distance );
            YSOS_LOG_DEBUG ( "chassis front distance: " << str_distance );
            float distance = atof ( str_distance.c_str() );
            // Strategy (1): to detect arriving
            YSOS_LOG_DEBUG ( "rcg_max_wait_: " << rcg_max_wait_ );
            YSOS_LOG_DEBUG ( "GetTimeElapse(rcg_start_): " << GetTimeElapse ( rcg_start_ ) );
            if ( customer_status == SERVER_STATUS_IDLE )
            {
                if ( rst == 0 && face_num > 0
                            && distance <= greet_dis_
                            && HandleMessage_start_ ==
                            boost::date_time::not_a_date_time )
                {
                    StartTimer ( HandleMessage_start_ );
                    YSOS_LOG_DEBUG ( "GetTimeElapse(HandleMessage_start_): " << GetTimeElapse ( HandleMessage_start_ ) );
                }
                if ( rst == 1 && face_num > 0 && distance <= greet_dis_ )
                {
                    customer_num_ = face_num;
                    customer_info_ = face_info;
                    //customer_info_.id_card = INFINATE_CSTM_ID; // to mark never said hello
                    CustomerArrive ( context );
                    facedet_flag_ = FACE_DET_HOME_GREET;
                }
                else if ( rst == 0 && face_num > 0
                            && distance <= greet_dis_
                            && ( GetTimeElapse ( HandleMessage_start_ ) >=
                                        rcg_max_wait_ ) )
                {
                    customer_num_ = face_num;
                    customer_info_ = face_info;
                    //customer_info_.id_card = INFINATE_CSTM_ID; // to mark never said hello
                    CustomerArrive ( context );
                    facedet_flag_ = FACE_DET_HOME_GREET;
                }
            }
            // Strategy (3): to detect arriving (robot special state)
            else if ( robot_state == ROBOT_MOVEPOINT_END )
            {
                if ( rst == 0 && face_num > 0 && distance <= greet_dis_ )
                {
                    data_ptr_->SetData ( ROBOT_STATE, ROBOT_CRUISE_SERVE );
                    customer_info_.track_id = face_info.track_id; // just to mark track_id
                    CustomerArrive ( context );
                    facedet_flag_ = FACE_DET_HOME_CHG_GREET;
                }
            }
            else if ( robot_state == ROBOT_MOVEDIR_END )
            {
                if ( rst == 0 && face_num > 0 && distance <= greet_dis_ )
                {
                    data_ptr_->SetData ( ROBOT_STATE, ROBOT_CRUISE_SERVE );
                    customer_info_.track_id = face_info.track_id; // just to mark track_id
                    CustomerArrive ( context );
                    facedet_flag_ = FACE_DET_CHG_GREET;
                }
            }
            // Strategy (4): to detect leaving
            else if ( customer_status == SERVER_STATUS_AT_SERVICE )
            {
                // wait rcgn info
                if ( facedet_flag_ != FACE_DET_NONE )
                {
                    YSOS_LOG_DEBUG ( "facedet_flag_ " << facedet_flag_ );
                    if ( rst == 0 )
                    {
                        if ( customer_info_.gender == 0 && customer_num_ == 1 )
                        {
                            // gender unknown, to update
                            if ( customer_info_.track_id == face_info.track_id )
                            {
                                customer_info_.age = face_info.age;
                                customer_info_.gender = face_info.gender;
                                customer_info_.id_card = INFINATE_CSTM_ID; // to mark never said hello
                            }
                        }
                    }
                    else if ( rst == 1 )
                    {
                        if ( customer_num_ > 1 || customer_info_.track_id == face_info.track_id )
                        {
                            customer_info_ = face_info;
                            facedet_collect_ |= 0x01;
                        }
                    }
                    else if ( rst == 2 )
                    {
                        if ( customer_num_ == 1 && customer_info_.track_id == face_info.track_id )
                        {
                            if ( face_info.rate == 0 )
                            {
                                // the different person
                                if ( facedet_flag_ == FACE_DET_CHG_GREET || facedet_flag_ == FACE_DET_HOME_GREET )
                                {
                                    facedet_flag_ = FACE_DET_HOME_GREET;
                                }
                                else if ( facedet_flag_ == FACE_DET_UPDATE_ONLY )
                                {
                                    mid_remind_falg_ = false;
                                }
                            }
                            else
                            {
                                // the same person
                                if ( facedet_flag_ == FACE_DET_HOME_GREET )
                                {
                                    facedet_flag_ = FACE_DET_HOME_GREET_SAME;
                                }
                            }
                            facedet_collect_ |= 0x02;
                        }
                    }
                    int new_det_flag = FACE_DET_INVAILD;
                    if ( facedet_collect_ == 0x03 || ( customer_num_ > 1  && facedet_collect_ == 0x01 ) )
                    {
                        new_det_flag = FACE_DET_NONE;
                    }
                    else if ( facedet_flag_ != FACE_DET_UPDATE_ONLY && GetTimeElapse ( rcg_start_ ) >= rcg_max_wait_ )
                    {
                        if ( customer_info_.id_card == INFINATE_CSTM_ID )
                        {
                            customer_info_.id_card.clear();
                        }
                        new_det_flag = FACE_DET_UPDATE_ONLY;
                    }
                    if ( new_det_flag != FACE_DET_INVAILD )
                    {
                        if ( facedet_flag_ == FACE_DET_HOME_GREET ) //需要问候，需要切主页，默认换人
                        {
                            CustomerServe ( 1, context );
                        }
                        else if ( facedet_flag_ == FACE_DET_CHG_GREET ) //换人才问候，不要切主页，默认没换人
                        {
                            YSOS_LOG_DEBUG ( "facedet_flag_ == FACE_DET_CHG_GREET: 换人才问候，不要切主页，默认没换人  =" );
                            CustomerServe ( -1, context );
                        }
                        else if ( facedet_flag_ == FACE_DET_HOME_CHG_GREET )  //换人才问候，需要切主页，默认没换人
                        {
                            CustomerServe ( 0, context );
                        }
                        else if ( facedet_flag_ == FACE_DET_HOME_GREET_SAME ) //同一个人，切主页
                        {
                            CustomerServe ( 1, context );
                        }
                        else if ( facedet_flag_ == FACE_DET_UPDATE_ONLY )  //换人重新识别（不需要问候，不要切主页）
                        {
                            YSOS_LOG_DEBUG ( "facedet_flag_ == FACE_DET_UPDATE_ONLY: 换人重新识别（不需要问候，不要切主页）  =" );
                            CustomerServe ( -1, context );
                        }
                        facedet_flag_ = new_det_flag;
                    }
                } // end if (facedet_flag_ != FACE_DET_NONE)
                // check whether leaved
                if ( rst == 0 )
                {
                    // get range No
                    unsigned int cur_range = 0;
                    while ( cur_range < range_num && distance > dis_range_[cur_range] )
                    {
                        ++cur_range;
                    }
                    if ( cur_range == 0 )
                    {
                        // check audio cap
                        if ( distance < greet_dis_ && !audio_open_ )
                        {
                            RequestService ( AUDIO_CAPTURE, AUDIO_OPEN, "text", "", context );
                            audio_open_ = true;
                        }
                        enfc_wait_tag_ = 0;
                        if ( face_num != 0 )
                        {
                            StartTimer ( last_serve_tm_ );
                            near_remind_falg_ = false;
                            int chged = TrackIdUpdated ( face_num, face_info );
                            if ( chged == YSOS_ERROR_SUCCESS )
                            {
                                customer_num_ = face_num;
                                customer_info_ = face_info;
                                if ( customer_num_ == 1 )
                                {
                                    char buff[16];
                                    sprintf ( buff, "%d", customer_info_.track_id );
                                    RequestService ( FACE_DETECT_MODULE, GetUtility()->ConvertToString (CMD_FACE_RCGN_1_1_CMP_BY_ID ), "text", buff, context );
                                }
                                facedet_collect_ = 0;
                                if ( facedet_flag_ == FACE_DET_NONE )
                                {
                                    facedet_flag_ = FACE_DET_UPDATE_ONLY;
                                }
                            }
                            if ( customer_num_ == 1 && chged != YSOS_ERROR_FAILED )
                            {
                                // do something later
                            }
                        }
                        else
                        {
                            if ( robot_state == ROBOT_CRUISE_SERVE )
                            {
                                std::string last_cruise;
                                data_ptr_->GetData ( LAST_CRUISE_STATUS, last_cruise );
                                if ( last_cruise == "WaitingService@TargetSearching@SpotSearching" )
                                {
                                    int elps = GetTimeElapse ( last_serve_tm_ );
                                    if ( !near_remind_falg_ && elps > near_remind_tm_ )
                                    {
                                        RequestService ( TTS_MODULE, TTS_IOCTL_ID, "text", near_remind_, context );
                                        near_remind_falg_ = true;
                                    }
                                    else if ( elps > wait_time_[0] )
                                    {
                                        YSOS_LOG_DEBUG ( "wait near timeout" );
                                        CustomerLeave ( robot_state, context );
                                    }
                                }
                            }
                        }
                    }
                    else   /// cur_range != 0
                    {
                        // check audio cap
                        if ( audio_open_ )
                        {
                            RequestService ( AUDIO_CAPTURE, AUDIO_CLOSE, "text", "", context );
                            audio_open_ = false;
                        }
                        if ( cur_range < range_num )
                        {
                            if ( !mid_remind_falg_ && face_num != 0 && customer_info_.id_card != INFINATE_CSTM_ID )
                            {
                                RequestService ( TTS_MODULE, TTS_IOCTL_ID, "text", mid_remind_, context );
                                mid_remind_falg_ = true;
                            }
                            if ( GetTimeElapse ( last_serve_tm_ ) > wait_time_[cur_range] )
                            {
                                YSOS_LOG_DEBUG ( "wait far timeout" );
                                CustomerLeave ( robot_state, context );
                            }
                        }
                        else
                        {
                            // never said hello, to leave directly;
                            // else, check last_range
                            if ( customer_info_.id_card == INFINATE_CSTM_ID || enfc_wait_tag_ == 1 || enforce_wait_ == 0 )
                            {
                                CustomerLeave ( robot_state, context );
                            }
                            else if ( enfc_wait_tag_ == 0 )
                            {
                                enfc_wait_tag_ = 2;
                                StartTimer ( enfc_wait_start_ );
                            }
                            else if ( GetTimeElapse ( enfc_wait_start_ ) > enforce_wait_ )
                            {
                                YSOS_LOG_DEBUG ( "enforce wait timeout" );
                                CustomerLeave ( robot_state, context );
                            }
                            else
                            {
                            }
                        } // end else (cur_range >= range_num)
                    } // end else (cur_range != 0)
                } // end rst==0
            } // end at_service
        }
        // from voice
        else if ( event_name ==
                    "move_cruise_chassis_event" )
        {
            // it will add to check the customer authority later
            std::string battery_low = "0";
            data_ptr_->GetData ( IS_BATTERY_LOW, battery_low );
            if ( battery_low == "1" )
            {
                RequestService ( TTS_MODULE, TTS_IOCTL_ID, "text", low_power_refuse_, context );
            }
            else
            {
                data_ptr_->SetData ( CURISE_ANS, "开始定点巡航" );
                DoEventNotifyService ( "customer_leave_event",  "customer_leave_callback", "", context );
                DoSwitchNotifyService ( "WaitingService@TargetSearching@SpotSearching", context );
                StartTimer ( prepare_start_ );
            }
        }
        else if ( event_name == "static_cruise_chassis_event" )
        {
            // it will add to check the customer authority later
            std::string battery_low = "0";
            data_ptr_->GetData ( IS_BATTERY_LOW, battery_low );
            if ( battery_low == "1" )
            {
                RequestService ( TTS_MODULE, TTS_IOCTL_ID, "text", low_power_refuse_, context );
            }
            else
            {
                data_ptr_->SetData ( CURISE_ANS, "开始原地巡航" );
                DoEventNotifyService ( "customer_leave_event", "customer_leave_callback", "", context );
                DoSwitchNotifyService ( "WaitingService@TargetSearching@LocalSearching", context );
                StartTimer ( prepare_start_ );
            }
        }
        else if ( event_name == "stop_move_chassis_event" )
        {
            // it will add to check the customer authority later
            if ( static_immediate_ )
            {
                data_ptr_->SetData ( CURISE_ANS, "进入静止模式" );
                DoEventNotifyService ( "customer_leave_event", "customer_leave_callback", "", context );
                DoSwitchNotifyService ( "WaitingService@TargetSearching@StaticSearching", context );
                StartTimer ( prepare_start_ );
            }
            else
            {
                RequestService ( TTS_MODULE, TTS_IOCTL_ID, "text", "进入静止模式", context );
                data_ptr_->SetData ( LAST_CRUISE_STATUS, "WaitingService@TargetSearching@StaticSearching" );
            }
        }
        else if ( event_name == "go_away_event" )
        {
            if ( customer_status == SERVER_STATUS_AT_SERVICE )
            {
                boost::this_thread::sleep ( boost::posix_time::milliseconds ( 1500 ) );
                CustomerLeave ( robot_state, context );
                StartTimer ( prepare_start_ );
            }
        }
        // customer operation
        else if ( event_name == "customer_operation_service" )
        {
            if ( CheckAvailable ( robot_state ) != YSOS_ERROR_SUCCESS )
            {
                return YSOS_ERROR_SUCCESS;
            }
            RequestService ( CHASSIS_MODULE, GetUtility()->ConvertToString ( CMD_CHASSIS_STOP_MOVE ), "text", "", context );
            // common deal
            data_ptr_->SetData ( CUSTOMER_STATUS, SERVER_STATUS_AT_SERVICE );
            StartTimer ( last_serve_tm_ );
            enfc_wait_tag_ = 0;
            near_remind_falg_ = false;
            if ( customer_status == SERVER_STATUS_IDLE )
            {
                facedet_collect_ = 0;
                may_change_ = false;
                mid_remind_falg_ = false;
                customer_num_ = 1;
                customer_info_.track_id = -1;
                customer_info_.gender = 0;
                customer_info_.id_card.clear();
                customer_info_.name.clear();
                CustomerServe ( 1, context );
                facedet_flag_ = FACE_DET_NONE;
            }
        }
        // front control
        else if ( event_name == "request_front_control_service" )
        {
            do
            {
                if ( robot_state == ROBOT_STATE_NULL )
                {
                    YSOS_LOG_DEBUG ( "but robot_state is not ready" );
                    break;
                }
                std::string battery_range = "0";
                data_ptr_->GetData ( IS_BATTERY_LOW, battery_range );
                if ( battery_range == "1" )
                {
                    YSOS_LOG_DEBUG ( "but battery is low" );
                    break;
                }
                DoSwitchNotifyService ( "FrontControl", context );
            } while ( 0 );
        }
        else if ( event_name == "release_front_idle_service" )
        {
            ResumeIdleState ( robot_state, "", context );
        }
        else if ( event_name == "release_front_serve_service" )
        {
            data_ptr_->SetData ( FRONT_CONTROL, "0" );
            StartTimer ( last_serve_tm_ );
            enfc_wait_tag_ = 0;
            near_remind_falg_ = false;
            facedet_collect_ = 0;
            may_change_ = false;
            mid_remind_falg_ = false;
            if ( customer_num_ == 0 || customer_info_.id_card == INFINATE_CSTM_ID )
            {
                customer_num_ = 1;
                customer_info_.track_id = -1;
                customer_info_.gender = 0;
                customer_info_.id_card.clear();
                customer_info_.name.clear();
            }
            CustomerServe ( 0, context );
            facedet_flag_ = FACE_DET_NONE;
        }
        return YSOS_ERROR_SUCCESS;
    }

    int CustomerDetStrategyCallback::CheckAvailable (
                const std::string &robot_state )
    {
        // work state
        std::string workstate;
        data_ptr_->GetData ( WORK_STATE, workstate );
        if ( workstate != "1" )
        {
            YSOS_LOG_DEBUG ( "work off" );
            return YSOS_ERROR_FAILED;
        }
        // robot state
        if ( robot_state == ROBOT_CRUISE_SERVE || robot_state == ROBOT_FAIL_CHARGE || robot_state == ROBOT_MOVEPOINT_END || robot_state == ROBOT_MOVEDIR_END )
        {
        }
        else if ( robot_state == ROBOT_CHARGING )
        {
            if ( !charging_serve_ )
            {
                return YSOS_ERROR_FAILED;
            }
        }
        else if ( robot_state == ROBOT_PREPARE_CRUISE )
        {
            double elaspse = GetTimeElapse ( prepare_start_ );
            if ( elaspse < prepare_cruise_tm_ )
            {
                return YSOS_ERROR_FAILED;
            }
            YSOS_LOG_DEBUG ( "Prepare Curise End: " << elaspse );
            data_ptr_->SetData ( ROBOT_STATE, ROBOT_CRUISE_SERVE );
        }
        else
        {
            return YSOS_ERROR_FAILED;
        }
        return YSOS_ERROR_SUCCESS;
    }

    int CustomerDetStrategyCallback::CustomerArrive ( CallbackInterface *context )
    {
        YSOS_LOG_DEBUG ( "Customer Arrive" );
        RequestService ( CHASSIS_MODULE, GetUtility()->ConvertToString ( CMD_CHASSIS_STOP_MOVE ), "text", "", context );
        HandleMessage_start_ = boost::date_time::not_a_date_time;
        StartTimer ( rcg_start_ );
        StartTimer ( last_serve_tm_ );
        enfc_wait_tag_ = 0;
        may_change_ = false;
        near_remind_falg_ = false;
        mid_remind_falg_ = false;
        facedet_collect_ = 0;
        if ( customer_num_ == 1 )
        {
            char buff[16];
            sprintf ( buff, "%d", customer_info_.track_id );
            RequestService ( FACE_DETECT_MODULE, GetUtility()->ConvertToString ( CMD_FACE_RCGN_1_1_CMP_BY_ID ), "text", buff, context );
        }
        data_ptr_->SetData ( CUSTOMER_STATUS, SERVER_STATUS_AT_SERVICE );
        return YSOS_ERROR_SUCCESS;
    }

    int CustomerDetStrategyCallback::CustomerServe (int greet_type, CallbackInterface *context )
    {
        YSOS_LOG_DEBUG ( "CustomerServe " << greet_type );
        // notify
        YSOS_LOG_DEBUG ( "CustomerDetStrategyCallback::CustomerServe: 上送人脸信息开始  =" << greet_type );
        NotifyCustomerServe ( context );
        YSOS_LOG_DEBUG ( "CustomerDetStrategyCallback::CustomerServe: 上送人脸信息结束 =" << greet_type );
        // update 1-1
        if ( customer_num_ == 1 )
        {
            if ( customer_info_.track_id != -1 )
            {
                char buff[16];
                sprintf ( buff, "%d", customer_info_.track_id );
                RequestService ( FACE_DETECT_MODULE, GetUtility()->ConvertToString ( CMD_FACE_RCGN_1_1_SET_BASE ), "text", buff, context );
            }
        }
        else
        {
            RequestService ( FACE_DETECT_MODULE, GetUtility()->ConvertToString ( CMD_FACE_RCGN_1_1_CLEAR_BASE ), "text", "", context );
        }
        switch ( greet_type )
        {
            case -1:
                return YSOS_ERROR_SUCCESS;
            case 0:
                data_ptr_->SetData ( "home_page_greet", "" );
                break;
            case 1:
            {
                std::string greet_word;
                if ( customer_num_ > 1 )
                {
                    greet_word = genderFM;   //多人打招呼
                }
                else
                {
                    if ( !customer_info_.name.empty() )
                    {
                        greet_word = customer_info_.name;
                    }
                    else
                    {
                        if ( customer_info_.gender == 1 )
                        {
                            greet_word = genderM;
                        }
                        else if ( customer_info_.gender == -1 )
                        {
                            greet_word = genderF;
                        }
                        else;
                    }
                    greet_word += "您好";    //单个人打招呼
                }
                send_name =  greet_word;
                YSOS_LOG_DEBUG ( "greet word " << greet_word );
                data_ptr_->SetData ( "home_page_greet", greet_word );
                break;
            }
            case 2:
                data_ptr_->SetData ( "home_page_greet", "again" );
                break;
        }
        int rst = DoSwitchNotifyService ( "OnService", context );
        if ( YSOS_ERROR_SUCCESS != rst )
        {
            YSOS_LOG_DEBUG ( "execute DoSwitchNotifyService failed" );
        }
        if ( send_name_flag == "1" )
        {
            Json::Value json_robot, json_orign, json_sceneSet;
            Json::FastWriter json_writer;
            if ( send_name == "您好" )
            {
                json_robot["answer_best"] = "";
            }
            else
            {
                json_robot["answer_best"] = send_name;
            }
            Json::Value arrayObj;
            arrayObj.append ( "chat" );
            json_robot["commands"] = arrayObj;
            json_robot["rc"] = "0";
            json_robot["rg"] = "0";
            json_robot["service"] = "chat";
            json_robot["text"] = "";
            json_orign["customerSaid"] = "";
            json_orign["robotState"] = "OnService";
            json_orign["sceneCount"] = "1";
            json_sceneSet["code"] = "100" ;
            json_sceneSet["commands"] = arrayObj;
            json_sceneSet["speakContent"] = "";
            json_orign["sceneSet"].append ( json_sceneSet );
            json_robot["orign_rspbody"] = json_orign;
            std::string menu_result = json_writer.write (json_robot );
            YSOS_LOG_DEBUG ( "send_anme = " << menu_result );
            int n_return = DoEventNotifyService ( "Answer_Type_Event", "OnYSOSResult", menu_result, context );
            if ( YSOS_ERROR_SUCCESS != n_return )
            {
                YSOS_LOG_DEBUG ( "execute EventNotify failed, n_return = " << n_return );
                n_return = YSOS_ERROR_FAILED;
            }
        }
        // audio auto open
        audio_open_ = true;
        return rst;
    }

    int CustomerDetStrategyCallback::CustomerLeave (const std::string &robot_state, CallbackInterface *context )
    {
        YSOS_LOG_DEBUG ( "CustomerLeave " << robot_state );
        // notify
        NotifyCustomerLeave ( context );
        std::string farewell;
        if ( customer_info_.id_card == INFINATE_CSTM_ID )
        {
            // never said hello
            YSOS_LOG_DEBUG ( "never said hello" );
        }
        else if ( farewell_.empty() )
        {
            // empty farewell
            YSOS_LOG_DEBUG ( "empty farewell" );
        }
        else
        {
            if ( customer_num_ == 1 )
            {
                if ( !customer_info_.name.empty() )
                {
                    farewell = customer_info_.name;
                }
                else
                {
                    if ( customer_info_.gender == 1 )
                    {
                        farewell = genderM;
                    }
                    else if ( customer_info_.gender == -1 )
                    {
                        farewell = genderF;
                    }
                    else;
                }
            }
            else
            {
            }
            farewell = "";
            farewell += farewell_;
        }
        ResetStatus();
        return ResumeIdleState ( robot_state, farewell, context );
    }

    void CustomerDetStrategyCallback::NotifyCustomerServe ( CallbackInterface *context )
    {
        char cstminfo[400];
        if ( customer_info_.age >= 0 && customer_info_.gender != 0 )
        {
            sprintf ( cstminfo, "{\"age\":%d,\"gender\":\"%s\",\"name\":\"%s\",\"id_card\":\"%s\"}",
                        customer_info_.age,
                        customer_info_.gender == 1 ? "male" : "female",
                        customer_info_.name.empty() ? "--" :
                        customer_info_.name.c_str(),
                        customer_info_.id_card.empty() ? "--" :
                        customer_info_.id_card.c_str() );
            DoEventNotifyService ( "customer_info_event", "customer_info_callback", cstminfo, context );
        }
        /*
        sprintf ( cstminfo,
                    "{\"type\":\"artificial_auxiliary_event\","
                    "\"data\":{\"messageType\":\"c2notice\",\"messageSource\": null,\"messageContent\":"
                    "{\"level\":3,\"content\":\"[人脸识别]姓名:%s,身份证号:%s,年龄:%d,性别:%s\"},\"messageTarget\":\"\"}}",
                    customer_info_.name.empty() ? "--" :
                    customer_info_.name.c_str(),
                    customer_info_.id_card.empty() ? "--" :
                    customer_info_.id_card.c_str(),
                    customer_info_.age,
                    customer_info_.gender == 1 ? "男" :
                    ( customer_info_.gender == -1 ? "女" : "--" ) );
        RequestService ( ARTIFICIAL_MODULE, GetUtility()->ConvertToString ( CMD_ARTIFICIAL_AUXILIARY_CALL ), "text", cstminfo, context );*/
    }

    void CustomerDetStrategyCallback::NotifyCustomerLeave (CallbackInterface *context )
    {
        DoEventNotifyService ( "customer_leave_event", "customer_leave_callback", "", context );
        /*std::string cstminfo =
                    "{\"type\":\"artificial_auxiliary_event\","
                    "\"data\":{\"messageType\":\"c2noticeRemove\",\"messageSource\": null,\"messageContent\":"
                    "{\"level\":3,\"content\":\"\"},\"messageTarget\":\"\"}}";
        RequestService ( ARTIFICIAL_MODULE, GetUtility()->ConvertToString ( CMD_ARTIFICIAL_AUXILIARY_HANGUP ), "text", cstminfo, context );*/
    }

    int CustomerDetStrategyCallback::ResumeIdleState ( const std::string &robot_state, const std::string &words, CallbackInterface *context )
    {
        int rst = YSOS_ERROR_SUCCESS;
        if ( robot_state == ROBOT_CHARGING || robot_state == ROBOT_FAIL_CHARGE )
        {
            std::string strcharging;
            data_ptr_->GetData ( IS_CHARGING, strcharging );
            if ( strcharging == "1" )
            {
                data_ptr_->SetData ( "on_charge_ans", words );
                rst = DoSwitchNotifyService ( "SuspendService@PowerManager@OnCharging", context );
            }
            else
            {
                data_ptr_->SetData ( "fail_charge_ans", words );
                rst = DoSwitchNotifyService ( "SuspendService@PowerManager@FailedToCharge", context );
            }
        }
        else
        {
            // If it is from front-control, the robot_state may be map_ready, go_home, or others.
            // At present, we simplify the cases first.
            std::string last_cruise;
            data_ptr_->GetData ( LAST_CRUISE_STATUS, last_cruise );
            YSOS_LOG_DEBUG ( "LAST_CRUISE_STATUS " << last_cruise );
            if ( last_cruise.empty() )
            {
                last_cruise = "WaitingService@TargetSearching@StaticSearching";
            }
            data_ptr_->SetData ( CURISE_ANS, words );
            YSOS_LOG_DEBUG ( "CURISE_ANS : " << words );
            rst = DoSwitchNotifyService ( last_cruise, context );
        }
        if ( YSOS_ERROR_SUCCESS != rst )
        {
            YSOS_LOG_DEBUG ( "execute DoSwitchNotifyService failed" );
        }
        return rst;
    }

    int CustomerDetStrategyCallback::ParserFaceInfo (BufferInterfacePtr input_buffer, int &num, CstmFaceInfo &face_info )
    {
        const char *buffer = reinterpret_cast<const char *>( GetBufferUtility()->GetBufferData ( input_buffer ) );
        if ( buffer == NULL )
        {
            YSOS_LOG_ERROR ( "buffer is NULL!" );
            return YSOS_ERROR_FAILED;
        }
        YSOS_LOG_DEBUG ( "input_buffer: " << buffer );
        Json::Reader js_reader;
        Json::Value js_value;
        if ( !js_reader.parse ( buffer, js_value, false ) )
        {
            YSOS_LOG_ERROR ( "ParserFaceInfoJsonStr failed!" );
            return YSOS_ERROR_FAILED;
        }
        js_value = js_value["data"];
        int in_num = js_value["face_num"].asInt();
        num = 0;
        if ( js_value["recognition"].asInt() == 0 )
        {
            for ( int i = 0; i < in_num; i++ )
            {
                Json::Value face = js_value["face"][ ( Json::UInt ) i];
                double rate = face["rate"].asDouble();
                if ( ++num == 1 || rate > face_info.x_rate )
                {
                    face_info.track_id = face["track_id"].asInt();
                    face_info.rate = rate;
                    face_info.x_rate = face["x_rate"].asDouble();
                    face_info.age = face["age"].asInt();
                    face_info.gender = face["gender"].asInt();
                    face_info.id_card = "";
                    face_info.name = "";
                }
            }
            if ( in_num != 0 )
            {
                printf ( "track %d\n", face_info.track_id );
            }
            return 0;
        }
        else if ( js_value["recognition"].asInt() == 1 )
        {
            if ( in_num == 0 )
            {
                return -1;
            }
            num = 1;
            Json::Value face = js_value["face"][ ( Json::UInt ) 0];
            face_info.track_id = face["track_id"].asInt();
            face_info.rate = 0;
            face_info.x_rate = 0;
            face_info.age = face["age"].asInt();
            face_info.gender = face["gender"].asInt();
            face_info.id_card = face["id_card"].asString();
            face_info.name = face["person_name"].asString();
            return 1;
        }
        else
        {
            num = 1;
            face_info.track_id = js_value["track_id"].asInt();
            face_info.rate = js_value["result"].asInt();
            return 2;
        }
    }

    int CustomerDetStrategyCallback::TrackIdUpdated (int face_num, CstmFaceInfo &face_info )
    {
        int rst = YSOS_ERROR_FAILED; // to confirm
        if ( customer_num_ == 1 )
        {
            if ( face_num == 1 )
            {
                if ( customer_info_.track_id != face_info.track_id )
                {
                    if ( face_info.rate > face_chg_rate_ )
                    {
                        may_change_ = false;
                        rst = YSOS_ERROR_SUCCESS; // changed (1->1)
                    }
                    else if ( !may_change_ )
                    {
                        may_change_ = true;
                        StartTimer ( chg_face_tm_ );
                    }
                    else if ( GetTimeElapse ( chg_face_tm_ ) > face_chg_ctu_ )
                    {
                        may_change_ = false;
                        rst = YSOS_ERROR_SUCCESS; // changed (1->1)
                    }
                }
                else
                {
                    may_change_ = false;
                    rst = YSOS_ERROR_SKIP;  // the same
                }
            }
            else
            {
                may_change_ = false;
                rst = YSOS_ERROR_SUCCESS; // changed (1->n)
            }
        }
        else
        {
            if ( face_num == 1 )
            {
                if ( face_info.rate > face_chg_rate_ )
                {
                    may_change_ = false;
                    rst = YSOS_ERROR_SUCCESS; // changed (n->1)
                }
                else if ( !may_change_ )
                {
                    may_change_ = true;
                    StartTimer ( chg_face_tm_ );
                }
                else if ( GetTimeElapse ( chg_face_tm_ ) > face_chg_ctu_ )
                {
                    may_change_ = false;
                    rst = YSOS_ERROR_SUCCESS; // changed (n->1)
                }
            }
        }
        YSOS_LOG_DEBUG ( "TrackIdUpdated " << rst );
        return rst;
    }

    void CustomerDetStrategyCallback::ResetStatus()
    {
        data_ptr_->SetData ( CUSTOMER_STATUS, SERVER_STATUS_IDLE );
        facedet_flag_ = FACE_DET_NONE;
        ClearCustomerInfo();
    }

    void CustomerDetStrategyCallback::ClearCustomerInfo()
    {
        customer_num_ = 0;
        customer_info_.id_card = INFINATE_CSTM_ID;
        customer_info_.age = -1;
        customer_info_.gender = 0;
        customer_info_.name.clear();
    }

    int CustomerDetStrategyCallback::RequestService (
                std::string service_name, std::string id,
                std::string type, std::string json_value,
                CallbackInterface *context )
    {
        YSOS_LOG_DEBUG ( "RequestService " << service_name << " " << id << " " << type << " " << json_value );
        int n_return = YSOS_ERROR_SUCCESS;
        ReqIOCtlServiceParam req_service;
        req_service.id = id;
        req_service.service_name = service_name;
        if ( !type.empty() )
        {
            req_service.type = type;
        }
        if ( !json_value.empty() )
        {
            req_service.value = json_value;
        }
        n_return = DoIoctlService ( req_service, context );
        if ( YSOS_ERROR_SUCCESS != n_return )
        {
            YSOS_LOG_DEBUG ( "execute DoIoctlService failed, n_return = " << n_return );
        }
        return n_return;
    }

    void CustomerDetStrategyCallback::StartTimer ( boost::posix_time::ptime &cur_tm )
    {
        cur_tm = boost::posix_time::microsec_clock::local_time();
    }

    double CustomerDetStrategyCallback::GetTimeElapse ( boost::posix_time::ptime &last_tm_ )
    {
        boost::posix_time::ptime curtime = boost::posix_time::microsec_clock::local_time();
        boost::posix_time::millisec_posix_time_system_config::time_duration_type time_elapse = curtime - last_tm_;
        return double ( time_elapse.total_milliseconds() ) / 1000.0;
    }

}